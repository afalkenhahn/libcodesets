TABLE OF CONTENTS

codesets.library/codesets.library
codesets.library/CodesetsConvertUTF16toUTF32
codesets.library/CodesetsConvertUTF16toUTF8
codesets.library/CodesetsConvertUTF32toUTF16
codesets.library/CodesetsConvertUTF32toUTF8
codesets.library/CodesetsConvertUTF8toUTF16
codesets.library/CodesetsConvertUTF8toUTF32
codesets.library/CodesetsDecodeB64A
codesets.library/CodesetsEncodeB64A
codesets.library/CodesetsFindA
codesets.library/CodesetsFindBestA
codesets.library/CodesetsFreeA
codesets.library/CodesetsIsLegalUTF8
codesets.library/CodesetsIsLegalUTF8Sequence
codesets.library/CodesetsSetDefaultA
codesets.library/CodesetsStrLenA
codesets.library/CodesetsSupportedA
codesets.library/CodesetsUTF8CreateA
codesets.library/CodesetsUTF8Len
codesets.library/CodesetsUTF8ToStrA

codesets.library/codesets.library

    Written bya Alfonso Ranieri alforan@tin.it
    
    codesets.library is an AmigaDOS shared library to handle with
    codesets and characters conversion.

    codesets.library is based on some code from UNICODE, some
    code from SimpleMail and some code from me.

    codesets.library is distributed under the terms of the GNU
    public licence II.

    Usually you will use just the following functions in your
    code:

    - CodesetsSupportedA

      It will build an array to be shown to the user and let him
      choose his preferred codeset.

      E.g. in a MUI you would do something like:

      STRPTR *array;

      if (array = CodesetsSupportedA(NULL))
      {
        DoMethod(list,MUIM_List_Insert,array,-1,MUIV_List_Insert_Sorted);
        CodesetsFreeA(array,NULL);
      }


    - CodesetsUTF8CreateA

      You use normal ascii in your code (internal structures,
      gadgets, ...), but when you are going to export (storing to
      disk, internet sending, ...) you must convert your string
      to UTF8. It is done via this function.

      The shortest invocation is:

      UTF8   *utf8;
      STRPTR str;

      if (utf8 = CodesetsUTF8Create(CODESETSA_Source,str,TAG_DONE))
      {
          ...

          CodesetsFreeA(utf8,NULL);
      }

      If you want to use your pool to allocate mem:

      UTF8   *utf8;
      STRPTR str;
      APTR   pool;

      if (utf8 = CodesetsUTF8Create(CODESETSA_Source,str,CODESETSA_Pool,pool,TAG_DONE))
      {
          ...

          FreeVecPooled(pool,utf,NULL);
      }

      If your pool is to be arbitrated via a semaphore:

      UTF8   *utf8;
      STRPTR str;
      APTR   pool;
      struct SignalSemaphore *sem;

      if (utf8 = CodesetsUTF8Create(CODESETSA_Source,str,CODESETSA_Pool,pool,CODESETSA_PoolSem,sem,TAG_DONE))
      {
          ...

          FreeVecPooled(pool,utf,NULL);
      }

      If you want to use your own buffer to reduce mem
      allocation:

      UTF8   *utf8;
      UBYTE  buf[256];

      if (utf8 = CodesetsUTF8Create(CODESETSA_Source,str,CODESETSA_Dest,buf,CODESETSA_DestLen,sizeof(buf),TAG_DONE))
      {
          ...

          if (utf8!=buf) CodesetsFreeA(utf8,NULL);
      }

      If your string are max MAXLEN chars long (e.g. image to be
      in a MUI application and you know the max size of your
      string gadgets), you should better supply your own buffer:

      UTF8   *utf8;
      UBYTE  buf[MAXSIZE*6+1];

      if (utf8 = CodesetsUTF8Create(CODESETSA_Source,str,CODESETSA_Dest,buf,CODESETSA_Dest,sizeof(buf),TAG_DONE))
      {
          ...
      }

      If you strings are very large and so you are sure there is
      no mem for them and or you have your own reasons to do
      that:

      static ULONG ASM SAVEDS
      destFun(REG(a0) struct Hook *hook,REG(a1) STRPTR buf,REG(a2) struct convertMsg *msg)
      {
          printf("[%3ld] [%s]\n",msg->len,buf);
          if (msg->state==CODESETV_End) printf("\n");

          return 0;
      }

      struct Hook dest;

      dest.h_Entry = (HOOKFUNC)destFun;
      CodesetsUTF8Create(CODESETSA_Source,str,CODESETSA_DestHook,&dest,TAG_DONE);

    - CodesetsUTF8ToStr

      It converts an utf8 to a string.

      See CodesetsUTF8CreateA

codesets.library/CodesetsConvertUTF16toUTF32

   NAME
    CodesetsConvertUTF16toUTF32 - converts from UTF16 to UTF32

   SYNOPSIS
    res = CodesetsConvertUTF16toUTF32(sourceStart,sourceEnd,targetStart,targetEnd,flags );
    D0                                A0          A1        A2          A3        D0

    ULONG CodesetsConvertUTF16toUTF32(const UTF16 **,const UTF16 *,UTF32 **,UTF32 *,ULONG);

   FUNCTION
    Converts UTF16 to UTF32.

   INPUTS

   RESULTS

   SEE ALSO

codesets.library/CodesetsConvertUTF16toUTF8

   NAME
    CodesetsConvertUTF16toUTF8 - converts from UTF16 to UTF8

   SYNOPSIS
    res = CodesetsConvertUTF16toUTF8(sourceStart,sourceEnd,targetStart,targetEnd,flags );
    D0                                A0          A1        A2          A3        D0

    ULONG CodesetsConvertUTF16toUTF8(const UTF16 **,const UTF16 *,UTF8 **,UTF8 *,ULONG);

   FUNCTION
    Converts UTF16 to UTF8.

   INPUTS

   RESULTS

   SEE ALSO

codesets.library/CodesetsConvertUTF32toUTF16

   NAME
    CodesetsConvertUTF32toUTF16 - converts from UTF32 to UTF16

   SYNOPSIS
    res = CodesetsConvertUTF32toUTF16(sourceStart,sourceEnd,targetStart,targetEnd,flags );
    D0                                A0          A1        A2          A3        D0

    ULONG CodesetsConvertUTF32toUTF16(const UTF32 **,const UTF32 *,UTF16 **,UTF16 *,ULONG);

   FUNCTION
    Converts UTF32 to UTF16.

   INPUTS

   RESULTS

   SEE ALSO

codesets.library/CodesetsConvertUTF32toUTF8

   NAME
    CodesetsConvertUTF32toUTF8 - converts from UTF32 to UTF8

   SYNOPSIS
    res = CodesetsConvertUTF32toUTF8(sourceStart,sourceEnd,targetStart,targetEnd,flags );
    D0                                A0          A1        A2          A3        D0

    ULONG CodesetsConvertUTF32toUTF8(const UTF32 **,const UTF32 *,UTF8 **,UTF8 *,ULONG);

   FUNCTION
    Converts UTF32 to UTF16.

   INPUTS

   RESULTS

   SEE ALSO

codesets.library/CodesetsConvertUTF8toUTF16

   NAME
    CodesetsConvertUTF8toUTF16 - converts from UTF8 to UTF16

   SYNOPSIS
    res = CodesetsConvertUTF8toUTF16(sourceStart,sourceEnd,targetStart,targetEnd,flags );
    D0                                A0          A1        A2          A3        D0

    ULONG CodesetsConvertUTF8toUTF16(const UTF8 **,const UTF8 *,UTF16 **,UTF16 *,ULONG);

   FUNCTION
    Converts UTF8 to UTF16.

   INPUTS

   RESULTS

   SEE ALSO

codesets.library/CodesetsConvertUTF8toUTF32

   NAME
    CodesetsConvertUTF8toUTF32 - converts from UTF8 to UTF32

   SYNOPSIS
    res = CodesetsConvertUTF8toUTF32(sourceStart,sourceEnd,targetStart,targetEnd,flags );
    D0                                A0          A1        A2          A3        D0

    ULONG CodesetsConvertUTF8toUTF32(const UTF8 **,const UTF8 *,UTF32 **,UTF32 *,ULONG);

   FUNCTION
    Converts UTF8 to UTF32.

   INPUTS

   RESULTS

   SEE ALSO

codesets.library/CodesetsDecodeB64A

   NAME
    CodesetsDecodeB64A - decodes from base 64

   SYNOPSIS
    res = CodesetsDecodeB64A(attrs);
    D0                       A0

    ULONG CodesetsDecodeB64A(struct TagItem *);

    res = CodesetsDecodeB64(tag1,...);
    D0                      A0

    ULONG CodesetsDecodeB64A(Tag,....);
    
  FUNCTION
    Decode from base 64.

    Defined attrs are:
    
    - CODESETSA_B64SourceString (STRPTR)
      The source string to decode

    - CODESETSA_B64SourceLen (ULONG)
      The length of CODESETSA_B64SourceString Must be supplied if
      CODESETSA_B64SourceString is used.
    
    - CODESETSA_B64SourceFile (STRPTR)
      Source file name.
        
    - CODESETSA_B64DestPtr (STRPTR *)
      Destination buffer pointer. Set to the allocated buffer.
      Must be supplied if CODESETSA_B64DestFile is not used. To
      be freed CodesetsFreeA()
          
    - CODESETSA_B64DestFile (STRPTR)     
      Destination file name. Must be supplied if
      CODESETSA_B64DestPtr is used.

    - CODESETSA_B64FLG_NtCheckErr (BOOL)
      Don't stop on error.
    
   INPUTS
    attrs - attributes list
    
   RESULTS
    res - result, one of (if 0 OK, if >0 error)
        B64_ERROR_OK
        B64_ERROR_MEM
        B64_ERROR_DOS
        B64_ERROR_INCOMPLETE
        B64_ERROR_ILLEGAL
    
   SEE ALSO

codesets.library/CodesetsEncodeB64A

   NAME
    CodesetsEncodeB64A - encodes to base 64

   SYNOPSIS
    res = CodesetsEncodeB64A(attrs);
    D0                       A0

    ULONG CodesetsEncodeB64A(struct TagItem *);

    res = CodesetsEncodeB64(tag1,...);
    D0                      A0

    ULONG CodesetsEncodeB64(Tag,....);
    
  FUNCTION
    Encodes to base 64.

    Defined attrs are:
    
    - CODESETSA_B64SourceString (STRPTR)
      The source string to encode

    - CODESETSA_B64SourceLen (ULONG)
      The length of CODESETSA_B64SourceString Must be supplied if
      CODESETSA_B64SourceString is used.
    
    - CODESETSA_B64SourceFile (STRPTR)
      Source file name.
        
    - CODESETSA_B64DestPtr (STRPTR *)
      Destination buffer pointer. Set to the allocated buffer.
      Must be supplied if CODESETSA_B64DestFile is not used. To
      be freed CodesetsFreeA()
          
    - CODESETSA_B64DestFile (STRPTR)     
      Destination file name. Must be supplied if
      CODESETSA_B64DestPtr is used.

    - CODESETSA_B64MaxLineLen (ULONG)
      Length of lines. 0<v<256 . Default: 72

    - CODESETSA_B64Unix (ULONG)
      If TRUE eol is \n otherwise \r\n . Default: TRUE
    
   INPUTS
    attrs - attributes list
    
   RESULTS
    res - result, one of (if 0 OK, if >0 error)
          o B64_ERROR_OK
          o B64_ERROR_MEM
          o B64_ERROR_DOS
          o B64_ERROR_INCOMPLETE
          o B64_ERROR_ILLEGAL
    
   SEE ALSO

codesets.library/CodesetsFindA

   NAME
    CodesetsFindA - finds a codeset

   SYNOPSIS
    codeset = CodesetsFindA(name,attrs);
    D0                      A0   A1

    struct codeset * CodesetsFindA(STRPTR,struct TagItem *);

    codeset = CodesetsFind(name,tag1,...);
    D0                     A0   A1

    struct codeset * CodesetsFind(STRPTR,Tag, ...);

   FUNCTION
    Finds a codeset by name.
    
    Defined attrs are:
    
    - CODESETSA_NoFail (ULONG)
      If TRUE the function never fails and returns the default
      codeset if the supplied codeset name can't be found.
      Default: TRUE
    
   INPUTS
    name - the codeset name (or alias) to find
    attrs - attribute list
        
   RESULTS
    codeset - the codeset or NULL

   SEE ALSO

codesets.library/CodesetsFindBestA

   NAME
    CodesetsFindBestA - finds the best codeset

   SYNOPSIS
    codeset = CodesetsFindBestA(text,textLen,errPtr,attrs);
    D0                          A0   A1      A2     A3

    struct codeset * CodesetsFindBestA(STRPTR,ULONG,int *,struct TagItem *);

    codeset = CodesetsFindBest(text,textLen,errPtr,tag1,...);
    D0                         A0   A1      A2     A3

    struct codeset * CodesetsFindBest(STRPTR,ULONG,int *,Tag,...);

   FUNCTION
    Returns the best codeset for the given text.
    
    No attribute defined.
    The function never fails.
        
   INPUTS
    text - the text to find the best codeset for
    textLen - text length
    errPtr -  position of the unresolved char 
    attrs - attributes list
               
   RESULTS
    codeset - the best codeset

   SEE ALSO

codesets.library/CodesetsFreeA

   NAME
    CodesetsFreeA - frees objects

   SYNOPSIS
    CodesetsFreeA(obj,attrs)
                  A0  A1

    void CodesetsFreeA(APTR,struct TagItem *);

    CodesetsFree(obj,tag1,...);
                 A0  A1

    void CodesetsFree(APTR,Tag,...);

   FUNCTION
    Frees object allocated by codesets.library.
    
    No attribute defined.
        
   INPUTS
    obj - the object to free
    attrs - attrbutes list
               
   RESULTS

   SEE ALSO

codesets.library/CodesetsIsLegalUTF8

   NAME
    CodesetsIsLegalUTF8 - check a char sequence 

   SYNOPSIS
    res = CodesetsIsLegalUTF8(source,length);
                              A0   D0

    ULONG CodesetsIsLegalUTF8(UTF8 *,ULONG);


   FUNCTION
    Checks if source is a valid UTF8 sequence.
    
   INPUTS
    source - the char sequence to check
    length - size of source
               
   RESULTS
    res - TRUE or FALSE
    
   SEE ALSO

codesets.library/CodesetsIsLegalUTF8Sequence

   NAME
    CodesetsIsLegalUTF8Sequence - check a char sequence 

   SYNOPSIS
    res = CodesetsIsLegalUTF8Sequence(source,end);
                                      A0     A1

    ULONG CodesetsIsLegalUTF8(UTF8 *,UTF8 *);

   FUNCTION
    Check if source is a valid UTF8 sequence.
    
   INPUTS
    source - the char sequence to check
    end - pointer to the end of the sequence to check
               
   RESULTS
    res - TRUE or FALSE
    
   SEE ALSO

codesets.library/CodesetsSetDefaultA

   NAME
    CodesetsSetDefaultA - sets the default codeset

   SYNOPSIS
    codeset = CodesetsSetDefaultA(name,attrs);
                                  A0   A1

    struct codeset * CodesetsSetDefaultA(STRPTR,struct TagItem *);

    codeset = CodesetsSetDefault(name,tag1,...);
                                 A0   A1

    struct codeset * CodesetsSetDefault(STRPTR,Tag,...);

   FUNCTION
    Sets the default codeset to name. The codeset if written in
    the environment var codeset_default.
    
   The defined attribute are:
   
    - CODESETSA_Save (ULONG)
      If TRUE the codeset is "saved", therwise it is "used".
    
   INPUTS
    name - the name of the codeset to set as default
    attrs - attributes list
               
   RESULTS
    codeset - the codeset or NULL
    
   SEE ALSO

codesets.library/CodesetsStrLenA

   NAME
    CodesetsStrLenA - return length

   SYNOPSIS
    len = CodesetsStrLenA(str,attrs)
                          A0  A1

    ULONG CodesetsStrLenA(STRPTR,struct TagItem *);

    len = CodesetsStrLen(str,tag1,...);
                         A0  A1

    ULONG CodesetsStrLen(STRPTR,Tag,...);

   FUNCTION
    Return the length of str as a UTF8 string.
    
   The defined attribute are:
   
    - CODESETSA_Codeset (struct codeset *)
      The codeset to use. Default: the default codeset

    - CODESETSA_SourceLen (ULONG)
      The length of str Default: UINT_MAX
    
   INPUTS
    str - the string to obtain length of 
    attrs - attributes list
               
   RESULTS
    len - the length of the UTF8
    
   SEE ALSO

codesets.library/CodesetsSupportedA

   NAME
    CodesetsSupportedA - returns supported codesets

   SYNOPSIS
    array = CodesetsSupportedA(attrs);
                               A0

    STRPTR * CodesetsSupportedA(struct TagItem *);

    array = CodesetsSupported(tag1,...);
                              A0

    STRPTR * CodesetsSupported(Tag,...);
    
   FUNCTION
    Returns the NULL terminated array of the supported codeset
    names. The array must be freed with CodesetsFreeA().
    
   No attribute defined.
    
   INPUTS
    attrs - attributes list
               
   RESULTS
    array - the names array or NULL
    
   SEE ALSO

codesets.library/CodesetsUTF8CreateA

   NAME
    CodesetsUTF8CreateA - creates a UTF8


   SYNOPSIS
    utf8 = CodesetsUTF8CreateA(attrs);
                               A0
    UTF8 * CodesetsUTF8CreateA(struct TagItem *);

    utf8 = CodesetsUTF8Create(tag1,...);
                              A0
    UTF8 * CodesetsUTF8Create(Tag,...);
    

   FUNCTION
    Creates an UTF8 from a string and a codeset.
   
    Defined attributes are:

    - CODESETSA_Codeset (struct codeset *)
      The codeset to use.
      Default: the default codeset
      
    - CODESETSA_Source (STRPTR)
      The string to create the utf8 from
      Must be supplied, otherwise the functions returns NULL.

    - CODESETSA_SourceLen (ULONG)
      Length of CODESETSA_Source
      Default: UINT_MAX

    - CODESETSA_Dest (STRPTR)
      Destination buffer.
      If you supply a valid buffer here, you must also set
      CODESETSA_DestLen to the length of your buffer. If
      CODESETSA_AllocIfNeeded is TRUE, CODESETSA_DestLen is
      checked to see if CODESETSA_Dest may contain the whole
      utf8. If CODESETSA_Dest can't contain the utf8, a brand new
      buffer is allocated. If CODESETSA_AllocIfNeeded is FALSE,
      up to CODESETSA_DestLen (ending 0 included) are written in
      CODESETSA_Dest. If CODESETSA_DestHook is supplied,
      CODESETSA_Dest is ignored.
      Default: NULL.

    - CODESETSA_DestHook (struct Hook *)
      Destination hook.

      If this is supplied, it is called with a partial converted
      string.

      The hook function should be declared as:

      ULONG ASM SAVEDS fun(REG(a0) struct Hook *hook,REG(a1) STRPTR buf,REG(a2) struct convertMsg *msg);

      - hook
        Your hook

      - buf
        The partial 0 termineted buffer

      - msg->state - one of

        o CODESETV_Translating
          More calls to came

        o CODESETV_End
          Last call

      - msg->Len
        strlen(buf)

      You may define the min length of the buffer via CODESETSA_DestLen.
      If so, accepted values are 16<=v<=sizeof_codeset_buffer.

      Don't count on this size to be fixed, even if you used
      CODESETSA_DestLen !

    - CODESETSA_DestLen (ULONG)
      If CODESETSA_DestHook is used, it rappresents the min
      length of the buffer that causes hook calls. Otherwise it
      is the size of the buffer supplied in CODESETSA_Dest. So if
      CODESETSA_DestHook is supplied, CODESETSA_DestLen is
      optional, otherwise it is required.

    - CODESETSA_DestLenPtr (ULONG *)
      If supplied, will contain the length of the utf8

    - CODESETSA_AllocIfNeeded (ULONG)
      If the destination buffer length is too small to contain
      the UTF8 a new buffer is allocated
      Default: TRUE

    - CODESETSA_Pool (APTR)
      If a new destination buffer is to be allocated (it happens
      if and only if CODESETS_DestHook is not used,
      CODESETSA_AllocIfNeeded is TRUE, CODESETS_Dest buffer is
      too small for the utf8) this pool is used. The result is to
      be freed via FreePooled(pool,utf8); If it is not supplied,
      the destination buffer is allocated from the internal
      memory pool and must be freed via CodesetsFreeA(utf8,NULL)

    - CODESETSA_PoolSem (struct SignalSemaphore *)
      A semaphore to lock when using CODESETSA_Pool
        

   INPUTS
    attrs - attributes list
               

   RESULTS
    utf8 - the utf8 string or NULL
           If CODESETSA_DestHook is used always NULL.
           If CODESETSA_DestHook is not used NULL means failure
           to allocate mem.

   SEE ALSO

codesets.library/CodesetsUTF8Len

   NAME
    CodesetsSupportedA - returns the length of utf8

   SYNOPSIS
    len = CodesetsUTF8Len(utf8);
                          A0

    ULONG CodesetsUTF8Len(UTF8 *);


   FUNCTION
    Returns the length of a UTF8. It is not the space needed to
    store the utf8, it is the number of chars in the utf8.
    

   INPUTS
    utf8 - the utf to find lenght of
               

   RESULTS
    len - length of utf8
    

   SEE ALSO

codesets.library/CodesetsUTF8ToStrA

   NAME
    CodesetsUTF8ToStrA - converts from utf8


   SYNOPSIS
    str = CodesetsUTF8ToStrA(attrs);
                             A0

    STRPTR  CodesetsUTF8ToStrA(attrs);

    str = CodesetsUTF8ToStr(tag1,...);
                            A0

    STRPTR CodesetsUTF8ToStr(Tag,...);


   FUNCTION
    Convert an utf8 to string via a codeset.

    Defined attributes are:

    - CODESETSA_Codeset (struct codeset *)
      The codeset to use.
      Default: the default codeset

    - CODESETSA_Source (STRPTR)
      The utf8 to create the string from Must be supplied,
      otherwise the functions returns NULL.

    - CODESETSA_SourceLen (ULONG)
      Length of CODESETSA_Source
      Default: UINT_MAX

    - CODESETSA_Dest (STRPTR)
      Destination buffer.
      If you supply a valid buffer here, you must also set
      CODESETSA_DestLen to the length of your buffer. If
      CODESETSA_AllocIfNeeded is TRUE, CODESETSA_DestLen is
      checked to see if CODESETSA_Dest may contain the whole
      str. If CODESETSA_Dest can't contain the str, a brand new
      buffer is allocated. If CODESETSA_AllocIfNeeded is FALSE,
      up to CODESETSA_DestLen (ending 0 included) are written in
      CODESETSA_Dest. If CODESETSA_DestHook is supplied,
      CODESETSA_Dest is ignored.
      Default: NULL.

    - CODESETSA_DestHook (struct Hook *)
      Destination hook.

      If this is supplied, it is called with a partial converted
      utf8.

      The hook function should be declared as:

      ULONG ASM SAVEDS fun(REG(a0) struct Hook *hook,REG(a1) STRPTR buf,REG(a2) struct convertMsg *msg);

      - hook
        Your hook

      - buf
        The partial 0 termineted buffer

      - msg->state - one of

        o CODESETV_Translating
          More calls to came

        o CODESETV_End
          Last call

      - msg->Len
        strlen(buf)

      You may define the min length of the buffer via CODESETSA_DestLen.
      If so, accepted values are 16<=v<=sizeof_codeset_buffer.

      Don't count on this size to be fixed, even if you used
      CODESETSA_DestLen !

      Note that broken UTF8 sequence may be passed in the buffer
      in partial calls!!!

    - CODESETSA_DestLen (ULONG)
      If CODESETSA_DestHook is used, it rappresents the min
      length of the buffer that causes hook calls. Otherwise it
      is the size of the buffer supplied in CODESETSA_Dest. So if
      CODESETSA_DestHook is supplied, CODESETSA_DestLen is
      optional, otherwise it is required.

    - CODESETSA_DestLenPtr (ULONG *)
      If supplied, will contain the length of the str

    - CODESETSA_AllocIfNeeded (ULONG)
      If the destination buffer length is too small to contain
      the str a new buffer is allocated
      Default: TRUE

    - CODESETSA_Pool (APTR)
      If a new destination buffer is to be allocated (it happens
      if and only if CODESETS_DestHook is not used,
      CODESETSA_AllocIfNeeded is TRUE, CODESETS_Dest buffer is
      too small for the str) this pool is used. The result is to
      be freed via FreePooled(pool,str); If it is not supplied,
      the destination buffer is allocated from the internal
      memory pool and must be freed via CodesetsFreeA(str,NULL)

    - CODESETSA_PoolSem (struct SignalSemaphore *)
      A semaphore to lock when using CODESETSA_Pool
    

   INPUTS
    attrs - attributes list
                   

   RESULTS
    str - the string or NULL
          If CODESETSA_DestHook is used always NULL.
          If CODESETSA_DestHook is not used NULL means failure
          to allocate mem.
    
   SEE ALSO

